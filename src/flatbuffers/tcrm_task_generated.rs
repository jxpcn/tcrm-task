// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod tcrm {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod task {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_STREAM_SOURCE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_STREAM_SOURCE: i8 = 1;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_STREAM_SOURCE: [StreamSource; 2] =
            [StreamSource::Stdout, StreamSource::Stderr];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct StreamSource(pub i8);
        #[allow(non_upper_case_globals)]
        impl StreamSource {
            pub const Stdout: Self = Self(0);
            pub const Stderr: Self = Self(1);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 1;
            pub const ENUM_VALUES: &'static [Self] = &[Self::Stdout, Self::Stderr];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Stdout => Some("Stdout"),
                    Self::Stderr => Some("Stderr"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for StreamSource {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for StreamSource {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for StreamSource {
            type Output = StreamSource;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl flatbuffers::EndianScalar for StreamSource {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for StreamSource {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for StreamSource {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_STATE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_STATE: i8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_STATE: [TaskState; 5] = [
            TaskState::Pending,
            TaskState::Initiating,
            TaskState::Running,
            TaskState::Ready,
            TaskState::Finished,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskState(pub i8);
        #[allow(non_upper_case_globals)]
        impl TaskState {
            pub const Pending: Self = Self(0);
            pub const Initiating: Self = Self(1);
            pub const Running: Self = Self(2);
            pub const Ready: Self = Self(3);
            pub const Finished: Self = Self(4);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Pending,
                Self::Initiating,
                Self::Running,
                Self::Ready,
                Self::Finished,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Pending => Some("Pending"),
                    Self::Initiating => Some("Initiating"),
                    Self::Running => Some("Running"),
                    Self::Ready => Some("Ready"),
                    Self::Finished => Some("Finished"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskState {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskState {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskState {
            type Output = TaskState;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl flatbuffers::EndianScalar for TaskState {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskState {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskState {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_TERMINATE_REASON: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_TERMINATE_REASON: u8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_TERMINATE_REASON: [TaskTerminateReason; 5] = [
            TaskTerminateReason::NONE,
            TaskTerminateReason::Timeout,
            TaskTerminateReason::Cleanup,
            TaskTerminateReason::DependenciesFinished,
            TaskTerminateReason::Custom,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskTerminateReason(pub u8);
        #[allow(non_upper_case_globals)]
        impl TaskTerminateReason {
            pub const NONE: Self = Self(0);
            pub const Timeout: Self = Self(1);
            pub const Cleanup: Self = Self(2);
            pub const DependenciesFinished: Self = Self(3);
            pub const Custom: Self = Self(4);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::Timeout,
                Self::Cleanup,
                Self::DependenciesFinished,
                Self::Custom,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::Timeout => Some("Timeout"),
                    Self::Cleanup => Some("Cleanup"),
                    Self::DependenciesFinished => Some("DependenciesFinished"),
                    Self::Custom => Some("Custom"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskTerminateReason {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskTerminateReason {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskTerminateReason {
            type Output = TaskTerminateReason;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl flatbuffers::EndianScalar for TaskTerminateReason {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskTerminateReason {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskTerminateReason {}
        pub struct TaskTerminateReasonUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_ERROR_TYPE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_ERROR_TYPE: i8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_ERROR_TYPE: [TaskErrorType; 5] = [
            TaskErrorType::IO,
            TaskErrorType::Handle,
            TaskErrorType::Channel,
            TaskErrorType::InvalidConfiguration,
            TaskErrorType::Custom,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskErrorType(pub i8);
        #[allow(non_upper_case_globals)]
        impl TaskErrorType {
            pub const IO: Self = Self(0);
            pub const Handle: Self = Self(1);
            pub const Channel: Self = Self(2);
            pub const InvalidConfiguration: Self = Self(3);
            pub const Custom: Self = Self(4);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::IO,
                Self::Handle,
                Self::Channel,
                Self::InvalidConfiguration,
                Self::Custom,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::IO => Some("IO"),
                    Self::Handle => Some("Handle"),
                    Self::Channel => Some("Channel"),
                    Self::InvalidConfiguration => Some("InvalidConfiguration"),
                    Self::Custom => Some("Custom"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskErrorType {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskErrorType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskErrorType {
            type Output = TaskErrorType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl flatbuffers::EndianScalar for TaskErrorType {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskErrorType {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskErrorType {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_EVENT: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_EVENT: u8 = 5;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_EVENT: [TaskEvent; 6] = [
            TaskEvent::NONE,
            TaskEvent::Started,
            TaskEvent::Output,
            TaskEvent::Ready,
            TaskEvent::Stopped,
            TaskEvent::Error,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskEvent(pub u8);
        #[allow(non_upper_case_globals)]
        impl TaskEvent {
            pub const NONE: Self = Self(0);
            pub const Started: Self = Self(1);
            pub const Output: Self = Self(2);
            pub const Ready: Self = Self(3);
            pub const Stopped: Self = Self(4);
            pub const Error: Self = Self(5);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 5;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::Started,
                Self::Output,
                Self::Ready,
                Self::Stopped,
                Self::Error,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::Started => Some("Started"),
                    Self::Output => Some("Output"),
                    Self::Ready => Some("Ready"),
                    Self::Stopped => Some("Stopped"),
                    Self::Error => Some("Error"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskEvent {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskEvent {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskEvent {
            type Output = TaskEvent;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl flatbuffers::EndianScalar for TaskEvent {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskEvent {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskEvent {}
        pub struct TaskEventUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_EVENT_STOP_REASON: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_EVENT_STOP_REASON: u8 = 6;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_EVENT_STOP_REASON: [TaskEventStopReason; 7] = [
            TaskEventStopReason::NONE,
            TaskEventStopReason::Finished,
            TaskEventStopReason::TerminatedTimeout,
            TaskEventStopReason::TerminatedCleanup,
            TaskEventStopReason::TerminatedDependenciesFinished,
            TaskEventStopReason::TerminatedCustom,
            TaskEventStopReason::Error,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskEventStopReason(pub u8);
        #[allow(non_upper_case_globals)]
        impl TaskEventStopReason {
            pub const NONE: Self = Self(0);
            pub const Finished: Self = Self(1);
            pub const TerminatedTimeout: Self = Self(2);
            pub const TerminatedCleanup: Self = Self(3);
            pub const TerminatedDependenciesFinished: Self = Self(4);
            pub const TerminatedCustom: Self = Self(5);
            pub const Error: Self = Self(6);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 6;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::Finished,
                Self::TerminatedTimeout,
                Self::TerminatedCleanup,
                Self::TerminatedDependenciesFinished,
                Self::TerminatedCustom,
                Self::Error,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::Finished => Some("Finished"),
                    Self::TerminatedTimeout => Some("TerminatedTimeout"),
                    Self::TerminatedCleanup => Some("TerminatedCleanup"),
                    Self::TerminatedDependenciesFinished => Some("TerminatedDependenciesFinished"),
                    Self::TerminatedCustom => Some("TerminatedCustom"),
                    Self::Error => Some("Error"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskEventStopReason {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskEventStopReason {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskEventStopReason {
            type Output = TaskEventStopReason;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl flatbuffers::EndianScalar for TaskEventStopReason {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskEventStopReason {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskEventStopReason {}
        pub struct TaskEventStopReasonUnionTableOffset {}

        pub enum TaskConfigOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskConfig<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskConfig<'a> {
            type Inner = TaskConfig<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TaskConfig<'a> {
            pub const VT_COMMAND: flatbuffers::VOffsetT = 4;
            pub const VT_ARGS: flatbuffers::VOffsetT = 6;
            pub const VT_WORKING_DIR: flatbuffers::VOffsetT = 8;
            pub const VT_ENV: flatbuffers::VOffsetT = 10;
            pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 12;
            pub const VT_ENABLE_STDIN: flatbuffers::VOffsetT = 14;
            pub const VT_READY_INDICATOR: flatbuffers::VOffsetT = 16;
            pub const VT_READY_INDICATOR_SOURCE: flatbuffers::VOffsetT = 18;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskConfig { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskConfigArgs<'args>,
            ) -> flatbuffers::WIPOffset<TaskConfig<'bldr>> {
                let mut builder = TaskConfigBuilder::new(_fbb);
                builder.add_timeout_ms(args.timeout_ms);
                if let Some(x) = args.ready_indicator {
                    builder.add_ready_indicator(x);
                }
                if let Some(x) = args.env {
                    builder.add_env(x);
                }
                if let Some(x) = args.working_dir {
                    builder.add_working_dir(x);
                }
                if let Some(x) = args.args {
                    builder.add_args(x);
                }
                if let Some(x) = args.command {
                    builder.add_command(x);
                }
                builder.add_ready_indicator_source(args.ready_indicator_source);
                builder.add_enable_stdin(args.enable_stdin);
                builder.finish()
            }

            #[inline]
            pub fn command(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(TaskConfig::VT_COMMAND, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn args(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                    >>(TaskConfig::VT_ARGS, None)
                }
            }
            #[inline]
            pub fn working_dir(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(TaskConfig::VT_WORKING_DIR, None)
                }
            }
            #[inline]
            pub fn env(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvEntry<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvEntry>>,
                    >>(TaskConfig::VT_ENV, None)
                }
            }
            #[inline]
            pub fn timeout_ms(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(TaskConfig::VT_TIMEOUT_MS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn enable_stdin(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TaskConfig::VT_ENABLE_STDIN, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn ready_indicator(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        TaskConfig::VT_READY_INDICATOR,
                        None,
                    )
                }
            }
            #[inline]
            pub fn ready_indicator_source(&self) -> StreamSource {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<StreamSource>(
                            TaskConfig::VT_READY_INDICATOR_SOURCE,
                            Some(StreamSource::Stdout),
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TaskConfig<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "command",
                        Self::VT_COMMAND,
                        true,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                    >>("args", Self::VT_ARGS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "working_dir",
                        Self::VT_WORKING_DIR,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnvEntry>>,
                    >>("env", Self::VT_ENV, false)?
                    .visit_field::<u64>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                    .visit_field::<bool>("enable_stdin", Self::VT_ENABLE_STDIN, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "ready_indicator",
                        Self::VT_READY_INDICATOR,
                        false,
                    )?
                    .visit_field::<StreamSource>(
                        "ready_indicator_source",
                        Self::VT_READY_INDICATOR_SOURCE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TaskConfigArgs<'a> {
            pub command: Option<flatbuffers::WIPOffset<&'a str>>,
            pub args: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >,
            >,
            pub working_dir: Option<flatbuffers::WIPOffset<&'a str>>,
            pub env: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvEntry<'a>>>,
                >,
            >,
            pub timeout_ms: u64,
            pub enable_stdin: bool,
            pub ready_indicator: Option<flatbuffers::WIPOffset<&'a str>>,
            pub ready_indicator_source: StreamSource,
        }
        impl<'a> Default for TaskConfigArgs<'a> {
            #[inline]
            fn default() -> Self {
                TaskConfigArgs {
                    command: None, // required field
                    args: None,
                    working_dir: None,
                    env: None,
                    timeout_ms: 0,
                    enable_stdin: false,
                    ready_indicator: None,
                    ready_indicator_source: StreamSource::Stdout,
                }
            }
        }

        pub struct TaskConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskConfigBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_command(&mut self, command: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskConfig::VT_COMMAND, command);
            }
            #[inline]
            pub fn add_args(
                &mut self,
                args: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskConfig::VT_ARGS, args);
            }
            #[inline]
            pub fn add_working_dir(&mut self, working_dir: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskConfig::VT_WORKING_DIR,
                    working_dir,
                );
            }
            #[inline]
            pub fn add_env(
                &mut self,
                env: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<EnvEntry<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskConfig::VT_ENV, env);
            }
            #[inline]
            pub fn add_timeout_ms(&mut self, timeout_ms: u64) {
                self.fbb_
                    .push_slot::<u64>(TaskConfig::VT_TIMEOUT_MS, timeout_ms, 0);
            }
            #[inline]
            pub fn add_enable_stdin(&mut self, enable_stdin: bool) {
                self.fbb_
                    .push_slot::<bool>(TaskConfig::VT_ENABLE_STDIN, enable_stdin, false);
            }
            #[inline]
            pub fn add_ready_indicator(
                &mut self,
                ready_indicator: flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskConfig::VT_READY_INDICATOR,
                    ready_indicator,
                );
            }
            #[inline]
            pub fn add_ready_indicator_source(&mut self, ready_indicator_source: StreamSource) {
                self.fbb_.push_slot::<StreamSource>(
                    TaskConfig::VT_READY_INDICATOR_SOURCE,
                    ready_indicator_source,
                    StreamSource::Stdout,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskConfigBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskConfigBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskConfig<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, TaskConfig::VT_COMMAND, "command");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskConfig<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskConfig");
                ds.field("command", &self.command());
                ds.field("args", &self.args());
                ds.field("working_dir", &self.working_dir());
                ds.field("env", &self.env());
                ds.field("timeout_ms", &self.timeout_ms());
                ds.field("enable_stdin", &self.enable_stdin());
                ds.field("ready_indicator", &self.ready_indicator());
                ds.field("ready_indicator_source", &self.ready_indicator_source());
                ds.finish()
            }
        }
        pub enum EnvEntryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct EnvEntry<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for EnvEntry<'a> {
            type Inner = EnvEntry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> EnvEntry<'a> {
            pub const VT_KEY: flatbuffers::VOffsetT = 4;
            pub const VT_VALUE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                EnvEntry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args EnvEntryArgs<'args>,
            ) -> flatbuffers::WIPOffset<EnvEntry<'bldr>> {
                let mut builder = EnvEntryBuilder::new(_fbb);
                if let Some(x) = args.value {
                    builder.add_value(x);
                }
                if let Some(x) = args.key {
                    builder.add_key(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn key(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(EnvEntry::VT_KEY, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn value(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(EnvEntry::VT_VALUE, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for EnvEntry<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "value",
                        Self::VT_VALUE,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct EnvEntryArgs<'a> {
            pub key: Option<flatbuffers::WIPOffset<&'a str>>,
            pub value: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for EnvEntryArgs<'a> {
            #[inline]
            fn default() -> Self {
                EnvEntryArgs {
                    key: None,   // required field
                    value: None, // required field
                }
            }
        }

        pub struct EnvEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnvEntryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(EnvEntry::VT_KEY, key);
            }
            #[inline]
            pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(EnvEntry::VT_VALUE, value);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> EnvEntryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                EnvEntryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<EnvEntry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, EnvEntry::VT_KEY, "key");
                self.fbb_.required(o, EnvEntry::VT_VALUE, "value");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for EnvEntry<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("EnvEntry");
                ds.field("key", &self.key());
                ds.field("value", &self.value());
                ds.finish()
            }
        }
        pub enum TimeoutReasonOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TimeoutReason<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TimeoutReason<'a> {
            type Inner = TimeoutReason<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TimeoutReason<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TimeoutReason { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args TimeoutReasonArgs,
            ) -> flatbuffers::WIPOffset<TimeoutReason<'bldr>> {
                let mut builder = TimeoutReasonBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for TimeoutReason<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct TimeoutReasonArgs {}
        impl<'a> Default for TimeoutReasonArgs {
            #[inline]
            fn default() -> Self {
                TimeoutReasonArgs {}
            }
        }

        pub struct TimeoutReasonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TimeoutReasonBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TimeoutReasonBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TimeoutReasonBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TimeoutReason<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TimeoutReason<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TimeoutReason");
                ds.finish()
            }
        }
        pub enum CleanupReasonOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CleanupReason<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CleanupReason<'a> {
            type Inner = CleanupReason<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CleanupReason<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CleanupReason { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args CleanupReasonArgs,
            ) -> flatbuffers::WIPOffset<CleanupReason<'bldr>> {
                let mut builder = CleanupReasonBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for CleanupReason<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct CleanupReasonArgs {}
        impl<'a> Default for CleanupReasonArgs {
            #[inline]
            fn default() -> Self {
                CleanupReasonArgs {}
            }
        }

        pub struct CleanupReasonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CleanupReasonBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CleanupReasonBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CleanupReasonBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CleanupReason<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CleanupReason<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CleanupReason");
                ds.finish()
            }
        }
        pub enum DependenciesFinishedReasonOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DependenciesFinishedReason<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DependenciesFinishedReason<'a> {
            type Inner = DependenciesFinishedReason<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> DependenciesFinishedReason<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DependenciesFinishedReason { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args DependenciesFinishedReasonArgs,
            ) -> flatbuffers::WIPOffset<DependenciesFinishedReason<'bldr>> {
                let mut builder = DependenciesFinishedReasonBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for DependenciesFinishedReason<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct DependenciesFinishedReasonArgs {}
        impl<'a> Default for DependenciesFinishedReasonArgs {
            #[inline]
            fn default() -> Self {
                DependenciesFinishedReasonArgs {}
            }
        }

        pub struct DependenciesFinishedReasonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DependenciesFinishedReasonBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> DependenciesFinishedReasonBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                DependenciesFinishedReasonBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DependenciesFinishedReason<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DependenciesFinishedReason<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DependenciesFinishedReason");
                ds.finish()
            }
        }
        pub enum CustomReasonOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CustomReason<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CustomReason<'a> {
            type Inner = CustomReason<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CustomReason<'a> {
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CustomReason { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CustomReasonArgs<'args>,
            ) -> flatbuffers::WIPOffset<CustomReason<'bldr>> {
                let mut builder = CustomReasonBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn message(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(CustomReason::VT_MESSAGE, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for CustomReason<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct CustomReasonArgs<'a> {
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for CustomReasonArgs<'a> {
            #[inline]
            fn default() -> Self {
                CustomReasonArgs {
                    message: None, // required field
                }
            }
        }

        pub struct CustomReasonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CustomReasonBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    CustomReason::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CustomReasonBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CustomReasonBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CustomReason<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, CustomReason::VT_MESSAGE, "message");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CustomReason<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CustomReason");
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        pub enum TaskErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskError<'a> {
            type Inner = TaskError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TaskError<'a> {
            pub const VT_KIND: flatbuffers::VOffsetT = 4;
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<TaskError<'bldr>> {
                let mut builder = TaskErrorBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.add_kind(args.kind);
                builder.finish()
            }

            #[inline]
            pub fn kind(&self) -> TaskErrorType {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskErrorType>(TaskError::VT_KIND, Some(TaskErrorType::IO))
                        .unwrap()
                }
            }
            #[inline]
            pub fn message(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(TaskError::VT_MESSAGE, None)
                }
            }
        }

        impl flatbuffers::Verifiable for TaskError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<TaskErrorType>("kind", Self::VT_KIND, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TaskErrorArgs<'a> {
            pub kind: TaskErrorType,
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for TaskErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                TaskErrorArgs {
                    kind: TaskErrorType::IO,
                    message: None,
                }
            }
        }

        pub struct TaskErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_kind(&mut self, kind: TaskErrorType) {
                self.fbb_
                    .push_slot::<TaskErrorType>(TaskError::VT_KIND, kind, TaskErrorType::IO);
            }
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskError::VT_MESSAGE, message);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskError");
                ds.field("kind", &self.kind());
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        pub enum StartedEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct StartedEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for StartedEvent<'a> {
            type Inner = StartedEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> StartedEvent<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                StartedEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args StartedEventArgs<'args>,
            ) -> flatbuffers::WIPOffset<StartedEvent<'bldr>> {
                let mut builder = StartedEventBuilder::new(_fbb);
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(StartedEvent::VT_TASK_NAME, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for StartedEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct StartedEventArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for StartedEventArgs<'a> {
            #[inline]
            fn default() -> Self {
                StartedEventArgs {
                    task_name: None, // required field
                }
            }
        }

        pub struct StartedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StartedEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    StartedEvent::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> StartedEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                StartedEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<StartedEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, StartedEvent::VT_TASK_NAME, "task_name");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for StartedEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("StartedEvent");
                ds.field("task_name", &self.task_name());
                ds.finish()
            }
        }
        pub enum OutputEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct OutputEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for OutputEvent<'a> {
            type Inner = OutputEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> OutputEvent<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_LINE: flatbuffers::VOffsetT = 6;
            pub const VT_SRC: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                OutputEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args OutputEventArgs<'args>,
            ) -> flatbuffers::WIPOffset<OutputEvent<'bldr>> {
                let mut builder = OutputEventBuilder::new(_fbb);
                if let Some(x) = args.line {
                    builder.add_line(x);
                }
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.add_src(args.src);
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(OutputEvent::VT_TASK_NAME, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn line(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(OutputEvent::VT_LINE, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn src(&self) -> StreamSource {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<StreamSource>(OutputEvent::VT_SRC, Some(StreamSource::Stdout))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for OutputEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("line", Self::VT_LINE, true)?
                    .visit_field::<StreamSource>("src", Self::VT_SRC, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct OutputEventArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub line: Option<flatbuffers::WIPOffset<&'a str>>,
            pub src: StreamSource,
        }
        impl<'a> Default for OutputEventArgs<'a> {
            #[inline]
            fn default() -> Self {
                OutputEventArgs {
                    task_name: None, // required field
                    line: None,      // required field
                    src: StreamSource::Stdout,
                }
            }
        }

        pub struct OutputEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OutputEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    OutputEvent::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn add_line(&mut self, line: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(OutputEvent::VT_LINE, line);
            }
            #[inline]
            pub fn add_src(&mut self, src: StreamSource) {
                self.fbb_
                    .push_slot::<StreamSource>(OutputEvent::VT_SRC, src, StreamSource::Stdout);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> OutputEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                OutputEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<OutputEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, OutputEvent::VT_TASK_NAME, "task_name");
                self.fbb_.required(o, OutputEvent::VT_LINE, "line");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for OutputEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("OutputEvent");
                ds.field("task_name", &self.task_name());
                ds.field("line", &self.line());
                ds.field("src", &self.src());
                ds.finish()
            }
        }
        pub enum ReadyEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ReadyEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ReadyEvent<'a> {
            type Inner = ReadyEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> ReadyEvent<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ReadyEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ReadyEventArgs<'args>,
            ) -> flatbuffers::WIPOffset<ReadyEvent<'bldr>> {
                let mut builder = ReadyEventBuilder::new(_fbb);
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(ReadyEvent::VT_TASK_NAME, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ReadyEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ReadyEventArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for ReadyEventArgs<'a> {
            #[inline]
            fn default() -> Self {
                ReadyEventArgs {
                    task_name: None, // required field
                }
            }
        }

        pub struct ReadyEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadyEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ReadyEvent::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ReadyEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ReadyEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ReadyEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, ReadyEvent::VT_TASK_NAME, "task_name");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ReadyEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ReadyEvent");
                ds.field("task_name", &self.task_name());
                ds.finish()
            }
        }
        pub enum StoppedEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct StoppedEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for StoppedEvent<'a> {
            type Inner = StoppedEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> StoppedEvent<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_EXIT_CODE: flatbuffers::VOffsetT = 6;
            pub const VT_REASON_TYPE: flatbuffers::VOffsetT = 8;
            pub const VT_REASON: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                StoppedEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args StoppedEventArgs<'args>,
            ) -> flatbuffers::WIPOffset<StoppedEvent<'bldr>> {
                let mut builder = StoppedEventBuilder::new(_fbb);
                if let Some(x) = args.reason {
                    builder.add_reason(x);
                }
                builder.add_exit_code(args.exit_code);
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.add_reason_type(args.reason_type);
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(StoppedEvent::VT_TASK_NAME, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn exit_code(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(StoppedEvent::VT_EXIT_CODE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn reason_type(&self) -> TaskEventStopReason {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskEventStopReason>(
                            StoppedEvent::VT_REASON_TYPE,
                            Some(TaskEventStopReason::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn reason(&self) -> flatbuffers::Table<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            StoppedEvent::VT_REASON,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_finished(&self) -> Option<FinishedReason<'a>> {
                if self.reason_type() == TaskEventStopReason::Finished {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { FinishedReason::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_terminated_timeout(&self) -> Option<TimeoutReason<'a>> {
                if self.reason_type() == TaskEventStopReason::TerminatedTimeout {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { TimeoutReason::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_terminated_cleanup(&self) -> Option<CleanupReason<'a>> {
                if self.reason_type() == TaskEventStopReason::TerminatedCleanup {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { CleanupReason::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_terminated_dependencies_finished(
                &self,
            ) -> Option<DependenciesFinishedReason<'a>> {
                if self.reason_type() == TaskEventStopReason::TerminatedDependenciesFinished {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { DependenciesFinishedReason::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_terminated_custom(&self) -> Option<CustomReason<'a>> {
                if self.reason_type() == TaskEventStopReason::TerminatedCustom {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { CustomReason::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_error(&self) -> Option<ErrorStopReason<'a>> {
                if self.reason_type() == TaskEventStopReason::Error {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ErrorStopReason::init_from_table(u) })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for StoppedEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("task_name", Self::VT_TASK_NAME, true)?
     .visit_field::<i32>("exit_code", Self::VT_EXIT_CODE, false)?
     .visit_union::<TaskEventStopReason, _>("reason_type", Self::VT_REASON_TYPE, "reason", Self::VT_REASON, true, |key, v, pos| {
        match key {
          TaskEventStopReason::Finished => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FinishedReason>>("TaskEventStopReason::Finished", pos),
          TaskEventStopReason::TerminatedTimeout => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TimeoutReason>>("TaskEventStopReason::TerminatedTimeout", pos),
          TaskEventStopReason::TerminatedCleanup => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CleanupReason>>("TaskEventStopReason::TerminatedCleanup", pos),
          TaskEventStopReason::TerminatedDependenciesFinished => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DependenciesFinishedReason>>("TaskEventStopReason::TerminatedDependenciesFinished", pos),
          TaskEventStopReason::TerminatedCustom => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CustomReason>>("TaskEventStopReason::TerminatedCustom", pos),
          TaskEventStopReason::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ErrorStopReason>>("TaskEventStopReason::Error", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct StoppedEventArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub exit_code: i32,
            pub reason_type: TaskEventStopReason,
            pub reason: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for StoppedEventArgs<'a> {
            #[inline]
            fn default() -> Self {
                StoppedEventArgs {
                    task_name: None, // required field
                    exit_code: 0,
                    reason_type: TaskEventStopReason::NONE,
                    reason: None, // required field
                }
            }
        }

        pub struct StoppedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StoppedEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    StoppedEvent::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn add_exit_code(&mut self, exit_code: i32) {
                self.fbb_
                    .push_slot::<i32>(StoppedEvent::VT_EXIT_CODE, exit_code, 0);
            }
            #[inline]
            pub fn add_reason_type(&mut self, reason_type: TaskEventStopReason) {
                self.fbb_.push_slot::<TaskEventStopReason>(
                    StoppedEvent::VT_REASON_TYPE,
                    reason_type,
                    TaskEventStopReason::NONE,
                );
            }
            #[inline]
            pub fn add_reason(
                &mut self,
                reason: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(StoppedEvent::VT_REASON, reason);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> StoppedEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                StoppedEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<StoppedEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, StoppedEvent::VT_TASK_NAME, "task_name");
                self.fbb_.required(o, StoppedEvent::VT_REASON, "reason");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for StoppedEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("StoppedEvent");
                ds.field("task_name", &self.task_name());
                ds.field("exit_code", &self.exit_code());
                ds.field("reason_type", &self.reason_type());
                match self.reason_type() {
                    TaskEventStopReason::Finished => {
                        if let Some(x) = self.reason_as_finished() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::TerminatedTimeout => {
                        if let Some(x) = self.reason_as_terminated_timeout() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::TerminatedCleanup => {
                        if let Some(x) = self.reason_as_terminated_cleanup() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::TerminatedDependenciesFinished => {
                        if let Some(x) = self.reason_as_terminated_dependencies_finished() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::TerminatedCustom => {
                        if let Some(x) = self.reason_as_terminated_custom() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::Error => {
                        if let Some(x) = self.reason_as_error() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("reason", &x)
                    }
                };
                ds.finish()
            }
        }
        pub enum ErrorEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ErrorEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ErrorEvent<'a> {
            type Inner = ErrorEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> ErrorEvent<'a> {
            pub const VT_TASK_NAME: flatbuffers::VOffsetT = 4;
            pub const VT_ERROR: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ErrorEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ErrorEventArgs<'args>,
            ) -> flatbuffers::WIPOffset<ErrorEvent<'bldr>> {
                let mut builder = ErrorEventBuilder::new(_fbb);
                if let Some(x) = args.error {
                    builder.add_error(x);
                }
                if let Some(x) = args.task_name {
                    builder.add_task_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn task_name(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(ErrorEvent::VT_TASK_NAME, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn error(&self) -> TaskError<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<TaskError>>(ErrorEvent::VT_ERROR, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ErrorEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "task_name",
                        Self::VT_TASK_NAME,
                        true,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<TaskError>>(
                        "error",
                        Self::VT_ERROR,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ErrorEventArgs<'a> {
            pub task_name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub error: Option<flatbuffers::WIPOffset<TaskError<'a>>>,
        }
        impl<'a> Default for ErrorEventArgs<'a> {
            #[inline]
            fn default() -> Self {
                ErrorEventArgs {
                    task_name: None, // required field
                    error: None,     // required field
                }
            }
        }

        pub struct ErrorEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_task_name(&mut self, task_name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ErrorEvent::VT_TASK_NAME,
                    task_name,
                );
            }
            #[inline]
            pub fn add_error(&mut self, error: flatbuffers::WIPOffset<TaskError<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TaskError>>(
                        ErrorEvent::VT_ERROR,
                        error,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ErrorEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ErrorEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ErrorEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, ErrorEvent::VT_TASK_NAME, "task_name");
                self.fbb_.required(o, ErrorEvent::VT_ERROR, "error");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ErrorEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ErrorEvent");
                ds.field("task_name", &self.task_name());
                ds.field("error", &self.error());
                ds.finish()
            }
        }
        pub enum FinishedReasonOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct FinishedReason<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for FinishedReason<'a> {
            type Inner = FinishedReason<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> FinishedReason<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                FinishedReason { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args FinishedReasonArgs,
            ) -> flatbuffers::WIPOffset<FinishedReason<'bldr>> {
                let mut builder = FinishedReasonBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for FinishedReason<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct FinishedReasonArgs {}
        impl<'a> Default for FinishedReasonArgs {
            #[inline]
            fn default() -> Self {
                FinishedReasonArgs {}
            }
        }

        pub struct FinishedReasonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FinishedReasonBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> FinishedReasonBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                FinishedReasonBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<FinishedReason<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for FinishedReason<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("FinishedReason");
                ds.finish()
            }
        }
        pub enum ErrorStopReasonOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ErrorStopReason<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ErrorStopReason<'a> {
            type Inner = ErrorStopReason<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> ErrorStopReason<'a> {
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ErrorStopReason { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ErrorStopReasonArgs<'args>,
            ) -> flatbuffers::WIPOffset<ErrorStopReason<'bldr>> {
                let mut builder = ErrorStopReasonBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn message(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            ErrorStopReason::VT_MESSAGE,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ErrorStopReason<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ErrorStopReasonArgs<'a> {
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for ErrorStopReasonArgs<'a> {
            #[inline]
            fn default() -> Self {
                ErrorStopReasonArgs {
                    message: None, // required field
                }
            }
        }

        pub struct ErrorStopReasonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorStopReasonBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ErrorStopReason::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ErrorStopReasonBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ErrorStopReasonBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ErrorStopReason<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, ErrorStopReason::VT_MESSAGE, "message");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ErrorStopReason<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ErrorStopReason");
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        pub enum TaskEventWrapperOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskEventWrapper<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskEventWrapper<'a> {
            type Inner = TaskEventWrapper<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TaskEventWrapper<'a> {
            pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_EVENT: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskEventWrapper { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskEventWrapperArgs,
            ) -> flatbuffers::WIPOffset<TaskEventWrapper<'bldr>> {
                let mut builder = TaskEventWrapperBuilder::new(_fbb);
                if let Some(x) = args.event {
                    builder.add_event(x);
                }
                builder.add_event_type(args.event_type);
                builder.finish()
            }

            #[inline]
            pub fn event_type(&self) -> TaskEvent {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskEvent>(TaskEventWrapper::VT_EVENT_TYPE, Some(TaskEvent::NONE))
                        .unwrap()
                }
            }
            #[inline]
            pub fn event(&self) -> Option<flatbuffers::Table<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            TaskEventWrapper::VT_EVENT,
                            None,
                        )
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_started(&self) -> Option<StartedEvent<'a>> {
                if self.event_type() == TaskEvent::Started {
                    self.event().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { StartedEvent::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_output(&self) -> Option<OutputEvent<'a>> {
                if self.event_type() == TaskEvent::Output {
                    self.event().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { OutputEvent::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_ready(&self) -> Option<ReadyEvent<'a>> {
                if self.event_type() == TaskEvent::Ready {
                    self.event().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { ReadyEvent::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_stopped(&self) -> Option<StoppedEvent<'a>> {
                if self.event_type() == TaskEvent::Stopped {
                    self.event().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { StoppedEvent::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_error(&self) -> Option<ErrorEvent<'a>> {
                if self.event_type() == TaskEvent::Error {
                    self.event().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { ErrorEvent::init_from_table(t) }
                    })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for TaskEventWrapper<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_union::<TaskEvent, _>(
                        "event_type",
                        Self::VT_EVENT_TYPE,
                        "event",
                        Self::VT_EVENT,
                        false,
                        |key, v, pos| match key {
                            TaskEvent::Started => v
                                .verify_union_variant::<flatbuffers::ForwardsUOffset<StartedEvent>>(
                                    "TaskEvent::Started",
                                    pos,
                                ),
                            TaskEvent::Output => v
                                .verify_union_variant::<flatbuffers::ForwardsUOffset<OutputEvent>>(
                                    "TaskEvent::Output",
                                    pos,
                                ),
                            TaskEvent::Ready => v
                                .verify_union_variant::<flatbuffers::ForwardsUOffset<ReadyEvent>>(
                                    "TaskEvent::Ready",
                                    pos,
                                ),
                            TaskEvent::Stopped => v
                                .verify_union_variant::<flatbuffers::ForwardsUOffset<StoppedEvent>>(
                                    "TaskEvent::Stopped",
                                    pos,
                                ),
                            TaskEvent::Error => v
                                .verify_union_variant::<flatbuffers::ForwardsUOffset<ErrorEvent>>(
                                    "TaskEvent::Error",
                                    pos,
                                ),
                            _ => Ok(()),
                        },
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TaskEventWrapperArgs {
            pub event_type: TaskEvent,
            pub event: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for TaskEventWrapperArgs {
            #[inline]
            fn default() -> Self {
                TaskEventWrapperArgs {
                    event_type: TaskEvent::NONE,
                    event: None,
                }
            }
        }

        pub struct TaskEventWrapperBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskEventWrapperBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_event_type(&mut self, event_type: TaskEvent) {
                self.fbb_.push_slot::<TaskEvent>(
                    TaskEventWrapper::VT_EVENT_TYPE,
                    event_type,
                    TaskEvent::NONE,
                );
            }
            #[inline]
            pub fn add_event(
                &mut self,
                event: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskEventWrapper::VT_EVENT,
                    event,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskEventWrapperBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskEventWrapperBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskEventWrapper<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskEventWrapper<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskEventWrapper");
                ds.field("event_type", &self.event_type());
                match self.event_type() {
                    TaskEvent::Started => {
                        if let Some(x) = self.event_as_started() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEvent::Output => {
                        if let Some(x) = self.event_as_output() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEvent::Ready => {
                        if let Some(x) = self.event_as_ready() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEvent::Stopped => {
                        if let Some(x) = self.event_as_stopped() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEvent::Error => {
                        if let Some(x) = self.event_as_error() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("event", &x)
                    }
                };
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `TaskEventWrapper`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_task_event_wrapper_unchecked`.
        pub fn root_as_task_event_wrapper(
            buf: &'_ [u8],
        ) -> Result<TaskEventWrapper<'_>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<TaskEventWrapper>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `TaskEventWrapper` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_task_event_wrapper_unchecked`.
        pub fn size_prefixed_root_as_task_event_wrapper(
            buf: &'_ [u8],
        ) -> Result<TaskEventWrapper<'_>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<TaskEventWrapper>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `TaskEventWrapper` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_task_event_wrapper_unchecked`.
        pub fn root_as_task_event_wrapper_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TaskEventWrapper<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<TaskEventWrapper<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `TaskEventWrapper` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_task_event_wrapper_unchecked`.
        pub fn size_prefixed_root_as_task_event_wrapper_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TaskEventWrapper<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<TaskEventWrapper<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a TaskEventWrapper and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `TaskEventWrapper`.
        pub unsafe fn root_as_task_event_wrapper_unchecked(buf: &'_ [u8]) -> TaskEventWrapper<'_> {
            unsafe { flatbuffers::root_unchecked::<TaskEventWrapper>(buf) }
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed TaskEventWrapper and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `TaskEventWrapper`.
        pub unsafe fn size_prefixed_root_as_task_event_wrapper_unchecked(
            buf: &'_ [u8],
        ) -> TaskEventWrapper<'_> {
            unsafe { flatbuffers::size_prefixed_root_unchecked::<TaskEventWrapper>(buf) }
        }
        #[inline]
        pub fn finish_task_event_wrapper_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<TaskEventWrapper<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_task_event_wrapper_buffer<
            'a,
            'b,
            A: flatbuffers::Allocator + 'a,
        >(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<TaskEventWrapper<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod Task
} // pub mod TCRM
